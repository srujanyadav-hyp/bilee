rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ==================== HELPER FUNCTIONS ====================
    
    // Check if user is authenticated
    function isSignedIn() {
      return request.auth != null;
    }
    
    // Check if user owns the document
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    // Check if user is the merchant (owns the resource)
    function isMerchant(merchantId) {
      return isSignedIn() && request.auth.uid == merchantId;
    }
    
    // Check if user is admin (for cloud functions)
    function isAdmin() {
      return isSignedIn() && 
             request.auth.token.get('admin', false) == true;
    }
    
    // Validate item data
    function isValidItem() {
      let data = request.resource.data;
      return data.name is string && 
             data.name.size() > 0 &&
             data.name.size() <= 200 &&
             data.price is number && 
             data.price >= 0 &&
             data.taxRate is number &&
             data.taxRate >= 0 &&
             data.taxRate <= 100 &&
             data.merchantId is string &&
             data.createdAt is timestamp &&
             data.updatedAt is timestamp;
    }
    
    // Validate billing session data
    function isValidSession() {
      let data = request.resource.data;
      return data.merchantId is string &&
             data.items is list &&
             data.items.size() > 0 &&
             data.items.size() <= 100 &&
             data.subtotal is number &&
             data.subtotal >= 0 &&
             data.tax is number &&
             data.tax >= 0 &&
             data.total is number &&
             data.total > 0 &&
             data.status in ['ACTIVE', 'EXPIRED', 'COMPLETED'] &&
             data.connectedCustomers is list &&
             data.createdAt is timestamp &&
             data.expiresAt is timestamp;
    }
    
    // Validate daily aggregate data
    function isValidAggregate() {
      let data = request.resource.data;
      return data.merchantId is string &&
             data.date is string &&
             data.date.matches('^[0-9]{4}-[0-9]{2}-[0-9]{2}$') &&
             data.total is number &&
             data.total >= 0 &&
             data.ordersCount is number &&
             data.ordersCount >= 0 &&
             data.itemsSold is list &&
             data.updatedAt is timestamp;
    }
    
    // ==================== USERS COLLECTION ====================
    
    match /users/{userId} {
      // Users can read and write only their own profile
      allow read, write: if isOwner(userId);
      
      // Allow creation during registration
      allow create: if isSignedIn() && request.auth.uid == userId;
      
      // Users can delete their own profile (for account deletion)
      allow delete: if isOwner(userId);
    }
    
    // ==================== ITEMS COLLECTION ====================
    
    match /items/{itemId} {
      // Merchants can read their own items
      allow read: if isSignedIn() && 
                     isMerchant(resource.data.merchantId);
      
      // Merchants can create items for themselves
      allow create: if isSignedIn() && 
                       isMerchant(request.resource.data.merchantId) &&
                       isValidItem();
      
      // Merchants can update their own items
      allow update: if isSignedIn() &&
                       isMerchant(resource.data.merchantId) &&
                       isMerchant(request.resource.data.merchantId) &&
                       resource.data.merchantId == request.resource.data.merchantId &&
                       isValidItem();
      
      // Merchants can delete their own items
      allow delete: if isSignedIn() &&
                       isMerchant(resource.data.merchantId);
    }
    
    // ==================== SESSIONS COLLECTION ====================
    
    match /sessions/{sessionId} {
      // Merchants can read their own sessions
      // Customers can read any session (they need sessionId to access)
      allow read: if isSignedIn() && (
                     isMerchant(resource.data.merchantId) ||
                     request.auth != null
                  );
      
      // Merchants can create sessions for themselves
      allow create: if isSignedIn() && 
                       isMerchant(request.resource.data.merchantId);
      
      // Merchants can update their own sessions
      // Customers can't update sessions
      allow update: if isSignedIn() &&
                       isMerchant(resource.data.merchantId) &&
                       request.resource.data.merchantId == resource.data.merchantId;
      
      // Sessions should not be deleted (keep for records)
      allow delete: if false;
    }
    
    // ==================== BILLING SESSIONS COLLECTION ====================
    
    match /billingSessions/{sessionId} {
      // Merchants can read their own sessions
      // Any authenticated customer can read sessions (they need sessionId from QR code)
      allow read: if isSignedIn() && (
                       isMerchant(resource.data.merchantId) ||
                       request.auth != null
                     );
      
      // Merchants can create sessions for themselves
      allow create: if isSignedIn() && 
                       isMerchant(request.resource.data.merchantId) &&
                       isValidSession() &&
                       request.resource.data.status == 'ACTIVE';
      
      // Merchants can update their own sessions
      // Customers can update to add themselves to connectedCustomers or confirm payment
      allow update: if isSignedIn() && (
                       // Merchant can update their own session
                       (isMerchant(resource.data.merchantId) &&
                        isMerchant(request.resource.data.merchantId) &&
                        resource.data.merchantId == request.resource.data.merchantId &&
                        (
                          // Allow status changes from ACTIVE to EXPIRED or COMPLETED
                          (resource.data.status == 'ACTIVE' && 
                           request.resource.data.status in ['EXPIRED', 'COMPLETED']) ||
                          // Allow payment status updates
                          (resource.data.paymentStatus == null && 
                           request.resource.data.paymentStatus in ['PENDING', 'PAID']) ||
                          (resource.data.paymentStatus == 'PENDING' && 
                           request.resource.data.paymentStatus == 'PAID') ||
                          // Allow adding connected customers
                          (resource.data.connectedCustomers.size() < request.resource.data.connectedCustomers.size())
                        )) ||
                       // Customer can add themselves to connectedCustomers array
                       (request.auth != null &&
                        request.resource.data.connectedCustomers.hasAny([request.auth.uid]) &&
                        !resource.data.connectedCustomers.hasAny([request.auth.uid]) &&
                        resource.data.merchantId == request.resource.data.merchantId) ||
                       // Customer can confirm payment
                       (request.auth != null &&
                        resource.data.connectedCustomers.hasAny([request.auth.uid]) &&
                        request.resource.data.keys().hasAny(['paymentConfirmed', 'paymentMethod', 'paymentAmount']))
                     );
      
      // Merchants can delete their own billing sessions (for account deletion)
      // Sessions owned by merchant can be deleted during account cleanup
      allow delete: if isSignedIn() && isMerchant(resource.data.merchantId);
    }
    
    // ==================== DAILY AGGREGATES COLLECTION ====================
    
    match /dailyAggregates/{aggregateId} {
      // Merchants can read their own aggregates
      allow read: if isSignedIn() && 
                     isMerchant(resource.data.merchantId);
      
      // Merchants and cloud functions can create/update aggregates
      allow create: if (isSignedIn() && 
                        isMerchant(request.resource.data.merchantId) &&
                        isValidAggregate()) ||
                       isAdmin();
      
      allow update: if (isSignedIn() &&
                        isMerchant(resource.data.merchantId) &&
                        isMerchant(request.resource.data.merchantId) &&
                        resource.data.merchantId == request.resource.data.merchantId &&
                        isValidAggregate()) ||
                       isAdmin();
      
      // Merchants can delete their own aggregates (for account deletion)
      allow delete: if isSignedIn() && isMerchant(resource.data.merchantId);
    }
    
    // ==================== RECEIPTS COLLECTION (FUTURE) ====================
    
    match /receipts/{receiptId} {
      // Merchants can read their own receipts
      // Customers can read receipts if:
      //   1. They own the receipt (customerId matches)
      //   2. OR the receipt has no customerId (walk-in customer, anyone can view)
      allow read: if isSignedIn() && (
                       isMerchant(resource.data.merchantId) ||
                       request.auth.uid == resource.data.customerId ||
                       !('customerId' in resource.data) ||
                       resource.data.customerId == null
                     );
      
      // Merchants can create receipts for their own sessions
      // Cloud functions can create receipts (backward compatibility)
      // Customers can create manual receipts for themselves
      allow create: if isAdmin() ||
                       (isSignedIn() && 
                        isMerchant(request.resource.data.merchantId)) ||
                       (isSignedIn() && 
                        request.resource.data.customerId == request.auth.uid &&
                        request.resource.data.manualEntry == true);
      
      // Receipts can be updated in multiple scenarios:
      // 1. Customer claiming a walk-in receipt (null customerId â†’ their ID)
      // 2. Customer who owns receipt updating notes field
      // 3. Merchant anonymizing their data during account deletion
      // 4. Customer anonymizing their data during account deletion
      allow update: if isSignedIn() && (
                       // Scenario 1: Customer claiming receipt
                       (resource.data.customerId == null &&
                        request.resource.data.customerId == request.auth.uid &&
                        request.resource.data.diff(resource.data).affectedKeys()
                          .hasOnly(['customerId', 'customerEmail', 'customerName', 'updatedAt'])) ||
                       // Scenario 2: Customer updating notes on their own receipt  
                       (request.auth.uid == resource.data.customerId &&
                        request.resource.data.diff(resource.data).affectedKeys()
                          .hasOnly(['notes', 'updatedAt'])) ||
                       // Scenario 3: Merchant anonymizing receipt during account deletion
                       (isMerchant(resource.data.merchantId) &&
                        request.resource.data.merchantId == 'DELETED_MERCHANT' &&
                        request.resource.data.merchantName == '[Deleted Merchant]') ||
                       // Scenario 4: Customer anonymizing receipt during account deletion
                       (request.auth.uid == resource.data.customerId &&
                        request.resource.data.customerId == null &&
                        request.resource.data.customerName == '[Deleted Customer]')
                     );
      
      // Users can delete receipts in two scenarios:
      // 1. Customer deleting their own receipts (customerId matches)
      // 2. Merchant deleting receipts they created (merchantId matches)
      allow delete: if isSignedIn() && (
                       request.auth.uid == resource.data.customerId ||
                       isMerchant(resource.data.merchantId)
                     );
    }
    
    // ==================== MERCHANT PROFILES (FUTURE) ====================
    
    match /merchants/{merchantId} {
      // Anyone can read public merchant profile
      allow read: if true;
      
      // Merchants can create/update their own profile
      allow create, update: if isSignedIn() && 
                               isMerchant(merchantId);
      
      // Merchants can delete their own profile (for account deletion)
      allow delete: if isSignedIn() && isMerchant(merchantId);
      
      // Sub-collection: Items under merchant
      match /items/{itemId} {
        // Merchants can read their own items
        allow read: if isSignedIn() && isMerchant(merchantId);
        
        // Merchants can create items for themselves
        allow create: if isSignedIn() && isMerchant(merchantId);
        
        // Merchants can update their own items  
        allow update: if isSignedIn() && isMerchant(merchantId);
        
        // Merchants can delete their own items (including during account deletion)
        allow delete: if isSignedIn() && isMerchant(merchantId);
      }
    }
    
    // ==================== CUSTOMER PROFILES (FUTURE) ====================
    
    match /customers/{customerId} {
      // Users can read their own profile
      allow read: if isSignedIn() && 
                     request.auth.uid == customerId;
      
      // Users can create/update their own profile
      allow create, update: if isSignedIn() && 
                               request.auth.uid == customerId;
      
      // Users cannot delete their profile
      allow delete: if false;
    }
    
    // ==================== USER PREFERENCES ====================
    
    match /userPreferences/{merchantId} {
      // Merchants can read/write their own preferences
      allow read, write: if isSignedIn() && 
                            isMerchant(merchantId);
    }
    
    // ==================== BUDGETS COLLECTION ====================
    
    match /budgets/{budgetId} {
      // Users can read their own budgets
      allow read: if isSignedIn() && 
                     request.auth.uid == resource.data.userId;
      
      // Users can create budgets for themselves
      allow create: if isSignedIn() && 
                       request.auth.uid == request.resource.data.userId &&
                       request.resource.data.category is string &&
                       request.resource.data.category.size() > 0 &&
                       request.resource.data.monthlyLimit is number &&
                       request.resource.data.monthlyLimit >= 0 &&
                       request.resource.data.createdAt is timestamp;
      
      // Users can update their own budgets
      allow update: if isSignedIn() && 
                       request.auth.uid == resource.data.userId &&
                       request.auth.uid == request.resource.data.userId;
      
      // Users can delete their own budgets
      allow delete: if isSignedIn() && 
                       request.auth.uid == resource.data.userId;
    }
    
    // ==================== DENY ALL OTHER COLLECTIONS ====================
    
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
